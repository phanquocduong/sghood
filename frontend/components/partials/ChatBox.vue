
<template>
  <ClientOnly>
    <div v-show="isOpen" class="chat-box">
      <!-- Loading nh·ªè trong khung chat -->
      <Loading :is-loading="isLoading" />

      <!-- N·ªôi dung chat ch·ªâ hi·ªÉn th·ªã khi kh√¥ng loading -->
      <template v-if="!isLoading">
        <audio ref="notiSound" src="/sounds/notification.mp3" preload="auto"></audio>
        <!-- Header -->
        <div class="chat-header">
          <span class="chat-title">H·ªó tr·ª£ ng∆∞·ªùi d√πng</span>
          <button class="chat-close" @click="$emit('close')">‚úï</button>
        </div>

        <!-- N·ªôi dung chat -->
        <div class="chat-body">
          <div class="chat-messages" ref="messageContainer">

            <div
              v-for="(msg, index) in messages"
              :key="index"
              :class="['chat-message-wrapper', msg.from === 'user' ? 'align-right' : 'align-left']"
            >
              <img
                :src="msg.from === 'user' ? avatarUrl : '/images/sghood_logo1.png'"
                
                alt="avatar"
                class="chat-avatar"
              />

              <div :class="['chat-message', msg.from === 'user' ? 'from-user' : 'from-admin']">
                <template v-if="msg.type === 'image'">
  <img :src="msg.content" class="chat-image" />
</template>
<template v-else>
  <span class="chat-text">{{ msg.text }}</span>
</template>

              </div>
            </div>
          </div>
        </div>

        <!-- G·ª£i √Ω c√¢u h·ªèi -->
        <div v-if="rawAction.length > 0" class="chat-suggestions">
          <ul class="suggestion-list">

            <li
              v-for="(hint,index) in rawAction"
              :key="index  "
              class="suggestion-item"
              @click="handleClick(hint,index)"
            >

              {{ hint }}
            </li>
          
          </ul>
        </div>

        <!-- Nh·∫≠p tin nh·∫Øn -->
        <div class="chat-input">
          
          <input
          
            type="text"
            v-model="newMessage"
            @keyup.enter="sendMessage"
            placeholder="Nh·∫≠p tin nh·∫Øn..."
          />
           <div class="dropzone-button" @click="selectFile">
  <i class="fa fas fa-camera"></i>
  <input
    ref="fileInput"
    type="file"
    accept="image/*"
    style="display: none"
    @change="handleFileUpload"
  />
</div>

          <button @click="sendMessage()">G·ª≠i</button>
  <button
  class="suggestion-item"
  style="background-color: #ffe0e0; color: #b71c1c"
  @click="resetHint"
>
  üßπ Reset hint
</button>


        </div>
      </template>
    </div>
  </ClientOnly>
</template>



<script setup>
import { ref, nextTick, onMounted, onBeforeUnmount, computed } from 'vue'
import { useAuthStore } from '~/stores/auth'
import { useCookie } from '#app'
import { collection, query, where, orderBy, onSnapshot, addDoc, serverTimestamp } from 'firebase/firestore'
import { useBehaviorStore } from '~/stores/behavior'
import { questionMap } from '~/utils/questionMap'
import { uploadImageToFirebase } from '~/utils/uploadImage'
const { $firebaseStorage } = useNuxtApp()
const emit = defineEmits(['close', 'unread'])
const authStore = useAuthStore()
const { user } = storeToRefs(authStore)
const currentUserId = ref(authStore.user?.id || null)
const token = ref(authStore.token || '')
const behavior = useBehaviorStore();
const { $api, $firebaseDb } = useNuxtApp()
const newMessage = ref(behavior.chat || '')
const messages = ref([])
const notiSound = ref(null)
const AdminId = ref(null)
const messageContainer = ref(null)
let unsubscribe = null // ƒë·ªÉ d·ª´ng listener khi unmount
const config = useRuntimeConfig()
const isLoading = ref(false);
const rawAction = ref([])
const lastRealtime = ref((Date.now()))
const fileInput = ref(null)
const props = defineProps({
  isOpen:Boolean
})
const resetHint = () => {
  localStorage.removeItem(local_hint_key.value)
  initActions() // c·∫≠p nh·∫≠t l·∫°i danh s√°ch rawAction
  console.log('Hint ƒë√£ ƒë∆∞·ª£c reset.')
}

const selectFile = () => {
  if (fileInput.value) {
    fileInput.value.click()
  }
}

const handleFileUpload = async (e) => {
  const file = e.target.files[0]
  if (!file) return

  try{

    const imageUrl = await uploadImageToFirebase(file, $firebaseStorage)
    console.log('Uploading image:', file)
console.log('Upload to:', $firebaseStorage)
    await sendMessage({
      content:imageUrl,
      type:'image'
    })
    console.log('image uploaded:', imageUrl)
  }catch(err){
    console.error('Upload image error:',err)
  }
}
watch(()=>props.isOpen,(open)=>{
  if(open){
    markMessagesAsRead()
  }
})

const local_hint_key = computed(()=>`usedHints_${currentUserId.value}`)

const getUserHint = ()=>{
  const raw = localStorage.getItem(local_hint_key.value)
  try{
    return raw ? JSON.parse(raw) : []
  }catch(e){
    return[]
  }

}
const saveUserHint = (hint)=>{
  const used = getUserHint( )
  if(!used.includes(hint)){
    used.push(hint)
    localStorage.setItem(local_hint_key.value, JSON.stringify(used))
  }
}

const route =useRoute()
watch(newMessage,(val)=>{
  behavior.updateChat(val)
})

const initActions = () => {
  const path = route.path
  const Filter = path.split('/').filter(Boolean)
  const mathKey = Object.keys(questionMap).find(k=> Filter.includes(k)) || '/'
  const origin = questionMap[mathKey] || questionMap['default']

  const raw = localStorage.getItem(local_hint_key.value)
  const useHints = raw ? JSON.parse(raw): [ ]
  rawAction.value = origin.filter(hint => !useHints.includes(hint)) 
}

const handleClick = (text,index)=>{
  sendMessage({ type: 'text', content: text })
  saveUserHint(text)
   const key = `usedHints_${currentUserId.value}`
  const raw = localStorage.getItem(key)
  const used = raw ? JSON.parse(raw) : []

  if (!used.includes(text)) {
    used.push(text)
    localStorage.setItem(key, JSON.stringify(used))
  }

  // Xo√° kh·ªèi danh s√°ch hi·ªán t·∫°i
  rawAction.value.splice(index, 1)
}
const send = (text) => {
  sendMessage(text)
}


const avatarUrl = computed(() =>
  user.value?.avatar
    ? config.public.baseUrl + user.value.avatar
    : '/images/dashboard-avatar.jpg'
)
const lastVisitedPage = computed(() => {
  return behavior.visitedPages.at(-1) || '/'
})


const scrollToBottom = () => {
  nextTick(() => {
    if (messageContainer.value) {
      messageContainer.value.scrollTop = messageContainer.value.scrollHeight
    }
  })
}

const initChat = async () => {
  isLoading.value = true

  try {
    // üö© G·ªçi API ƒë·ªÉ g√°n admin
    const res = await $api('/messages/start-chat', {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${token.value}`,
        'X-XSRF-TOKEN': useCookie('XSRF-TOKEN').value
      },
      body: {
        message: 'Xin ch√†o, t√¥i c·∫ßn h·ªó tr·ª£'
      }
    })

    if (!res?.admin_id) {
      console.warn('Kh√¥ng l·∫•y ƒë∆∞·ª£c admin t·ª´ ph·∫£n h·ªìi start-chat')
      return
    }

    AdminId.value = res.admin_id

    // üö© Clear tin nh·∫Øn c≈© (n·∫øu c√≥)
    messages.value = []

    const chatId = [currentUserId.value, AdminId.value].sort().join('_')

    const msgQuery = query(
      collection($firebaseDb, 'messages'),
      where('chatId', '==', chatId),
      orderBy('createdAt', 'asc')
    )

    unsubscribe = onSnapshot(msgQuery, snapshot => {
      const allMessages = snapshot.docs.map(doc => {
        const d = doc.data()
        return {
          id: doc.id,
          from: d.sender_id === currentUserId.value ? 'user' : 'admin',
          text: d.text,
          type: d.type || 'text',
          content: d.content || '',
          createdAt: d.createdAt?.toMillis?.() || Date.now()
        }
      })

      messages.value = allMessages
      scrollToBottom()

      // Th√¥ng b√°o m·ªõi n·∫øu admin v·ª´a tr·∫£ l·ªùi
      const lastMsg = allMessages.at(-1)
      if (
        lastMsg?.from === 'admin' &&
        lastMsg.createdAt > lastRealtime.value
      ) {
        lastRealtime.value = Date.now()
        localStorage.setItem('lastRealtime', lastRealtime.value.toString())

        emit('unread')
        if (notiSound.value) {
          notiSound.value.currentTime = 0
          notiSound.value.play().catch(err => {
            console.warn('Kh√¥ng th·ªÉ ph√°t √¢m thanh:', err)
          })
        }
      }
    })
  } catch (error) {
    console.error('initChat error:', error)
  } finally {
    isLoading.value = false
  }
}

const sendMessage = async (payload = null) => {
  const type = payload?.type || 'text'
  const content = String(payload?.content || newMessage.value).trim()
  if (!content || !AdminId.value) return

  try {
    const chatId = [currentUserId.value, AdminId.value].sort().join('_')

    scrollToBottom()
    newMessage.value = ''

    // G·ª≠i tin nh·∫Øn l√™n Firestore
    await addDoc(collection($firebaseDb, 'messages'), {
      text: type === 'text' ? content : '',
      content: type === 'image' ? content : '',
      type,
      sender_id: currentUserId.value,
      receiver_id: AdminId.value,
      createdAt: serverTimestamp(),
      is_read: false,
      chatId
    })

    if (type === 'text') behavior.clearChat()

    scrollToBottom()
  } catch (err) {
    console.error('sendMessage error:', err)
  }
}


onMounted(() => {
  const storeRealtime = localStorage.getItem('lastRealtime')
  if(!storeRealtime){
    lastRealtime.value= 0

  }else{
    lastRealtime.value = parseInt(storeRealtime)
  }
  initChat() 
  initActions()

})

onBeforeUnmount(() => {
  if (unsubscribe) unsubscribe()
})

const markMessagesAsRead = ()=>{
  lastRealtime.value = Date.now()
  localStorage.setItem('lastRealtime', lastRealtime.value.toString())
}
</script>


<style scoped>
.chat-message-wrapper {
  display: flex;
  align-items: flex-end;
  /* Cho avatar v√† text th·∫≥ng h√†ng d∆∞·ªõi */
  margin-bottom: 10px;
  gap: 8px; /* kho·∫£ng c√°ch gi·ªØa avatar v√† tin nh·∫Øn */
   

}

.align-right {
  justify-content: flex-end;
  flex-direction: row-reverse;
}

.align-left {
  justify-content: flex-start;
  flex-direction: row;
}

.chat-avatar {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  object-fit: cover;
  flex-shrink: 0;
  align-self: flex-start;
  transform: translateY(4px);
}

.chat-message {
  max-width: 70%;
  padding: 8px 12px;
  border-radius: 12px;
  word-break: break-word;
  background-color: #f1f1f1;
  color: #333;
  display: inline-block;
}


.chat-avatar {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  object-fit: cover;
  flex-shrink: 0;
}

.chat-box {
  position: fixed;
  bottom: 160px;
  right: 24px;
  width: 400px;
  max-height: 600px;
  display: flex;
  flex-direction: column;
  background: white;
  border-radius: 16px;
  box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
  overflow: hidden;
  z-index: 10001;
  height: 500px;

}

/* Header */
.chat-header {
  background-color: #e53935;
  color: white;
  padding: 12px 16px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.chat-title {
  font-weight: bold;
  font-size: 16px;
}

.chat-close {
  background: transparent;
  border: none;
  color: white;
  font-size: 18px;
  cursor: pointer;
}

/* G·ª£i √Ω */
.chat-suggestions {
  padding: 8px 12px;
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  align-items: flex-start;
}

.suggestion-title {
  width: 100%;
  font-weight: 500;
  font-size: 13px;
  margin-bottom: 4px;
  color: #444;
}

.suggestion-list {
  list-style: none;
  padding: 0;
  margin: 0;
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
}

.suggestion-item {
  background-color: #f1f1f1;
  color: #333;
  padding: 8px 12px;
  border-radius: 12px;
  font-size: 13px;
  cursor: pointer;
  max-width: 100%;
  word-break: break-word;
  transition: background-color 0.2s;
}

.suggestion-item:hover {
  background-color: #ddd;
}

/* Tin nh·∫Øn */
.chat-body {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.chat-messages {
  flex: 1;
  display: flex;
  flex-direction: column;
  /* ‚úÖ d√πng h∆∞·ªõng b√¨nh th∆∞·ªùng */
  padding: 12px;
  overflow-y: auto;
  background-color: #f8f8f8;
}

.chat-message {
  margin-bottom: 10px;
  max-width: 80%;
  word-break: break-word;
  padding: 8px 12px;
  border-radius: 12px;
}

.from-user {
  background-color: #f1f1f1;
  align-self: flex-end;
  margin-left: auto;
  color: #333;
}

.from-admin {
  align-self: flex-start;
  margin-right: auto;
  background-color: #e6f4ff;
  color: #0b5394;
}

/* Input */
.chat-input {
  display: flex;
  border-top: 1px solid #ddd;
  padding: 8px 16px;
  background: #fff;
  align-items: center;
  height: 60px;
}

.chat-input input {
  flex: 1;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 8px;
  margin-right: 8px;
  height: 40px;
  margin-top: 15px;
}

.chat-input button {
  background-color: #e53935;
  color: white;
  border: none;
  padding: 8px 16px;
  border-radius: 8px;
  cursor: pointer;
  height: 40px;
}

.chat-input button:hover {
  background-color: #d32f2f;
}
.loading-overlay {
    position: absolute;
    inset: 0;
    background: white;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 1000;
}

.spinner {
    width: 50px;
    height: 50px;
    border: 5px solid #f3f3f3;
    border-top: 5px solid #f91942;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

p {
    color: #333;
    margin-top: 10px;
    font-size: 16px;
}

@keyframes spin {
    to {
        transform: rotate(360deg);
    }
}
.dropzone-button {
  width: 40px;
  height: 40px;
  background-color: #e53935;
  border-radius: 8px;
  margin-right: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
}
.dropzone-button:hover {
 background-color: #d32f2f;
}
.dropzone-button::before {
  font-size: 18px;
  color: white;
}

.dropzone .dz-message {
  display: none !important;
}
.dropzone-button i {
  color: white;
  font-size: 15px;
}
.chat-image {
  max-width: 200px;
  border-radius: 8px;
}
</style>